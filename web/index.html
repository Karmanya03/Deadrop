<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>deadrop ‚Äî encrypted drop</title>
    <link rel="icon" type="image/png" href="../assets/deadrop-logo.png">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0a; --surface: #141414; --border: #222;
            --text: #e0e0e0; --text-dim: #666; --accent: #00ff88;
            --accent-hover: #00cc6a; --error: #ff4444; --warning: #ffaa00;
        }
        body {
            font-family: 'SF Mono', 'JetBrains Mono', 'Fira Code', 'Cascadia Code', monospace;
            background: var(--bg); color: var(--text);
            display: flex; justify-content: center; align-items: center;
            min-height: 100vh; padding: 1rem;
        }
        .container {
            text-align: center; max-width: 520px; width: 100%;
            display: flex; flex-direction: column; align-items: center;
        }
        .logo-img {
            width: 100%; max-width: 480px; height: auto;
            margin-bottom: 2rem; user-select: none;
            pointer-events: none; display: block;
        }
        .hidden { display: none !important; }
        .card {
            background: var(--surface); border: 1px solid var(--border);
            border-radius: 12px; padding: 2rem; margin-bottom: 1.5rem; width: 100%;
        }
        .file-row {
            display: flex; justify-content: space-between;
            padding: 0.5rem 0; border-bottom: 1px solid var(--border); font-size: 0.85rem;
        }
        .file-row:last-child { border-bottom: none; }
        .meta-label { color: var(--text-dim); }
        .meta-value { color: var(--text); font-weight: 500; }
        .filename { max-width: 220px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
        .pw-section { display: none; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border); }
        .pw-section.active { display: block; }
        .pw-label { font-size: 0.85rem; color: var(--warning); margin-bottom: 0.75rem; }
        .pw-input {
            width: 100%; padding: 10px 14px; background: var(--bg);
            border: 1px solid var(--border); border-radius: 6px;
            color: var(--text); font-family: inherit; font-size: 0.9rem;
            outline: none; transition: border-color 0.15s ease;
        }
        .pw-input:focus { border-color: var(--accent); }
        .progress-container { margin: 1.5rem 0; display: none; }
        .progress-bar { width: 100%; height: 6px; background: var(--border); border-radius: 3px; overflow: hidden; }
        .progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.15s ease-out; border-radius: 3px; }
        .progress-text { font-size: 0.75rem; color: var(--text-dim); margin-top: 0.5rem; }
        .status { color: var(--text-dim); margin: 1rem 0; font-size: 0.9rem; min-height: 1.5em; }
        .status.deriving { display: none; }
        .status.deriving.active { display: block; color: var(--warning); }
        .btn {
            background: var(--accent); color: #000; border: none;
            padding: 14px 40px; font-size: 1rem; font-weight: 700;
            font-family: inherit; border-radius: 8px; cursor: pointer;
            transition: all 0.15s ease; letter-spacing: 0.05em;
        }
        .btn:hover { background: var(--accent-hover); transform: translateY(-1px); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; transform: none; }
        .error { color: var(--error); }
        .success { color: var(--accent); }
        .warning { color: var(--warning); }
        .burned { text-align: center; padding: 1rem 0; }
        .burned-icon { font-size: 2.5rem; margin-bottom: 0.75rem; }
        .burned-title { font-size: 1.1rem; font-weight: 600; margin-bottom: 0.5rem; }
        .burned-sub { font-size: 0.8rem; color: var(--text-dim); line-height: 1.5; }
        .footer { font-size: 0.7rem; color: var(--text-dim); margin-top: 1rem; }
        .footer a { color: var(--accent); text-decoration: none; }
        .shield { font-size: 0.75rem; color: var(--text-dim); margin-top: 1rem; }
        @media (max-width: 540px) {
            body { padding: 0.75rem; }
            .card { padding: 1.25rem; }
            .btn { padding: 12px 32px; font-size: 0.9rem; width: 100%; }
            .file-row { font-size: 0.8rem; }
        }
        @media (max-width: 360px) {
            .logo-img { max-width: 280px; }
            .card { padding: 1rem; }
            .btn { padding: 10px 24px; font-size: 0.85rem; }
        }
    </style>
</head>
<body>
    <div class="container">
        <img src="../assets/deadrop-logo.png" alt="deadrop" class="logo-img">

        <!-- Loading state -->
        <div id="loading" class="card" style="text-align:center; color:var(--text-dim);">
            Loading drop metadata...
        </div>

        <!-- Burned state -->
        <div id="burned" class="card hidden">
            <div class="burned">
                <div class="burned-icon">üí•</div>
                <div class="burned-title">This drop has been destroyed</div>
                <div class="burned-sub">It was already downloaded and self-destructed.<br>Like it never existed.</div>
            </div>
        </div>

        <!-- Not found state -->
        <div id="notfound" class="card hidden">
            <div class="burned">
                <div class="burned-icon">üï≥</div>
                <div class="burned-title">Drop not found</div>
                <div class="burned-sub">This drop has expired or never existed.<br>The void stares back.</div>
            </div>
        </div>

        <!-- Main download card -->
        <div id="main" class="hidden">
            <div class="card">
                <div class="file-info">
                    <div class="file-row">
                        <span class="meta-label">üìÑ File</span>
                        <span class="meta-value filename" id="filename"></span>
                    </div>
                    <div class="file-row">
                        <span class="meta-label">üì¶ Size</span>
                        <span class="meta-value" id="filesize"></span>
                    </div>
                    <div class="file-row">
                        <span class="meta-label">‚è∞ Expires</span>
                        <span class="meta-value" id="expires"></span>
                    </div>
                    <div class="file-row">
                        <span class="meta-label">üé∞ Downloads left</span>
                        <span class="meta-value" id="remaining"></span>
                    </div>
                    <div class="file-row">
                        <span class="meta-label">üîê Encryption</span>
                        <span class="meta-value">XChaCha20-Poly1305</span>
                    </div>

                    <!-- Password section (hidden by default) -->
                    <div id="pw-section" class="pw-section">
                        <div class="pw-label">
                            <span class="lock-icon">üîí</span> This drop requires a password
                        </div>
                        <div class="pw-input-group">
                            <input type="password" id="pw-input" class="pw-input"
                                   placeholder="Enter password..." autocomplete="off" autofocus>
                        </div>
                        <div id="pw-status" class="status deriving">
                            Deriving key with Argon2id... this may take a few seconds
                        </div>
                    </div>
                </div>

                <!-- Download button (non-password drops) -->
                <button id="btn-download" class="btn" onclick="startDownload()">
                    ‚¨á Download & Decrypt
                </button>

                <!-- Unlock + Download button (password drops) -->
                <button id="btn-unlock" class="btn hidden" onclick="unlockAndDownload()">
                    üîì Unlock & Download
                </button>

                <!-- Progress -->
                <div id="progress-section" class="progress-container">
                    <div class="progress-bar">
                        <div id="progress-fill" class="progress-fill"></div>
                    </div>
                    <div id="progress-text" class="progress-text">Downloading...</div>
                </div>

                <div id="status-msg" class="status"></div>
            </div>
        </div>
    </div>

    <script>
        /* ‚îÄ‚îÄ State ‚îÄ‚îÄ */
        let dropId;
        let encryptionKey;
        let passwordSalt;
        let isPasswordDrop = false;
        let meta = null;
        let wasmModule = null;

        /* ‚îÄ‚îÄ Init ‚îÄ‚îÄ */
        (async function init() {
            const pathParts = window.location.pathname.split('/');
            dropId = pathParts[pathParts.length - 1] || pathParts[pathParts.length - 2];

            const fragment = window.location.hash.slice(1);
            if (fragment) {
                history.replaceState(null, '', window.location.pathname);
            }

            if (!fragment) {
                showError('No decryption key found in URL. The link may be incomplete.');
                return;
            }

            if (fragment.startsWith('pw:')) {
                isPasswordDrop = true;
                passwordSalt = fragment.slice(3);
            } else {
                isPasswordDrop = false;
                encryptionKey = fragment;
            }

            // Load WASM
            try {
                const wasmImport = await import('/wasm/deadrop_wasm.js');
                await wasmImport.default('/wasm/deadrop_wasm_bg.wasm');
                wasmModule = wasmImport;
            } catch (e) {
                console.error('WASM load failed:', e);
                showError('Failed to load decryption module.');
                return;
            }

            // Fetch metadata
            try {
                const resp = await fetch(`/api/meta/${dropId}`);

                if (resp.status === 410) {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('burned').classList.remove('hidden');
                    return;
                }
                if (resp.status === 404) {
                    document.getElementById('loading').classList.add('hidden');
                    document.getElementById('notfound').classList.remove('hidden');
                    return;
                }
                if (!resp.ok) throw new Error('HTTP ' + resp.status);

                meta = await resp.json();
            } catch (e) {
                console.error('Metadata fetch failed:', e);
                showError('Failed to load drop metadata.');
                return;
            }

            // Populate UI
            document.getElementById('filename').textContent = meta.filename;
            document.getElementById('filesize').textContent = meta.size;
            document.getElementById('remaining').textContent = meta.downloads_remaining;

            if (meta.expires_at) {
                const exp = new Date(meta.expires_at);
                const now = new Date();
                const diffMs = exp - now;
                if (diffMs <= 0) {
                    document.getElementById('expires').textContent = 'Expired';
                    document.getElementById('expires').style.color = 'var(--error)';
                } else {
                    const mins = Math.floor(diffMs / 60000);
                    const hrs = Math.floor(mins / 60);
                    if (hrs > 0) {
                        document.getElementById('expires').textContent = `${hrs}h ${mins % 60}m`;
                    } else {
                        document.getElementById('expires').textContent = `${mins}m`;
                    }
                }
            }

            document.getElementById('loading').classList.add('hidden');
            document.getElementById('main').classList.remove('hidden');

            // Password drops
            if (isPasswordDrop) {
                document.getElementById('pw-section').classList.add('active');
                document.getElementById('btn-download').classList.add('hidden');
                document.getElementById('btn-unlock').classList.remove('hidden');
                document.getElementById('pw-input').addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') unlockAndDownload();
                });
            }

            if (meta.expires_at) {
                setupExpiryWatcher(new Date(meta.expires_at));
            }
        })();

        /* ‚îÄ‚îÄ Password unlock ‚îÄ‚îÄ */
        async function unlockAndDownload() {
            const password = document.getElementById('pw-input').value;
            if (!password) {
                showError('Please enter the password.');
                return;
            }

            const btn = document.getElementById('btn-unlock');
            const pwStatus = document.getElementById('pw-status');

            btn.disabled = true;
            btn.textContent = 'Deriving key...';
            pwStatus.className = 'status deriving active';

            try {
                encryptionKey = wasmModule.derive_key_from_password(password, passwordSalt);
                pwStatus.classList.add('hidden');
                await startDownload();
            } catch (e) {
                console.error('Key derivation failed:', e);
                btn.disabled = false;
                btn.textContent = 'üîì Unlock & Download';
                showError('Key derivation failed: ' + e);
            }
        }

        /* ‚îÄ‚îÄ Download: WebSocket P2P primary, HTTP fallback ‚îÄ‚îÄ */
        async function startDownload() {
            if (!encryptionKey) {
                showError('No encryption key available.');
                return;
            }

            const btn = document.getElementById('btn-download');
            const btnUnlock = document.getElementById('btn-unlock');
            btn.disabled = true;
            btnUnlock.disabled = true;

            const progressSection = document.getElementById('progress-section');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            progressSection.style.display = 'block';

            try {
                let encrypted;
                let viaP2P = false;

                // Try WebSocket P2P first
                try {
                    progressText.textContent = '‚ö° Connecting P2P...';
                    encrypted = await downloadViaWS(progressFill, progressText);
                    viaP2P = true;
                } catch (wsErr) {
                    console.log('P2P unavailable, using HTTP:', wsErr.message);
                    encrypted = await downloadViaHTTP(progressFill, progressText);
                }

                // Decrypt ‚Äî yield to browser so UI updates before heavy WASM work
                progressFill.style.width = '100%';
                progressText.textContent = viaP2P
                    ? 'üîì Decrypting P2P transfer...'
                    : 'üîì Decrypting...';

                // Let the browser repaint before blocking on WASM decrypt
                await new Promise(r => setTimeout(r, 100));

                let decrypted;
                try {
                    decrypted = wasmModule.decrypt_blob(encrypted, encryptionKey);
                } catch (e) {
                    if (isPasswordDrop) {
                        throw new Error('Decryption failed ‚Äî wrong password? The key didn\'t match.');
                    }
                    throw new Error('Decryption failed ‚Äî key mismatch or corrupted data.');
                }

                // Free encrypted data from memory immediately after decryption
                encrypted = null;

                // Save file
                progressText.textContent = 'Saving file...';
                const blob = new Blob([decrypted], { type: meta.mime || 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = meta.filename || 'deadrop-file';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                showSuccess(viaP2P
                    ? '‚úÖ Downloaded via P2P ‚Äî zero relay!'
                    : '‚úÖ File decrypted and downloaded!');
                progressSection.style.display = 'none';

                // Wipe keys from memory
                encryptionKey = null;
                passwordSalt = null;

            } catch (e) {
                console.error('Download failed:', e);
                progressSection.style.display = 'none';

                if (isPasswordDrop && e.message.includes('wrong password')) {
                    const btnRetry = document.getElementById('btn-unlock');
                    btnRetry.disabled = false;
                    btnRetry.textContent = 'üîì Unlock & Download';
                    encryptionKey = null;
                    document.getElementById('pw-input').value = '';
                    document.getElementById('pw-input').focus();
                }
                showError(e.message);
            }
        }

        /* ‚îÄ‚îÄ WebSocket P2P download ‚îÄ‚îÄ */
        function downloadViaWS(progressFill, progressText) {
            return new Promise((resolve, reject) => {
                const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
                const ws = new WebSocket(`${proto}//${location.host}/ws/blob/${dropId}`);
                ws.binaryType = 'arraybuffer';

                let chunks = [];
                let received = 0;
                let totalSize = 0;
                let gotData = false;

                // 5s timeout for initial connection
                const timeout = setTimeout(() => {
                    ws.close();
                    reject(new Error('P2P connection timeout'));
                }, 5000);

                ws.onopen = () => clearTimeout(timeout);

                ws.onmessage = (event) => {
                    if (typeof event.data === 'string') {
                        try {
                            const msg = JSON.parse(event.data);
                            if (msg.type === 'start') {
                                totalSize = msg.encrypted_size || 0;
                                progressText.textContent = '‚ö° Streaming via P2P...';
                            } else if (msg.type === 'done') {
                                progressText.textContent = 'üß© Assembling chunks...';
                                // Yield before heavy memory operation
                                setTimeout(() => {
                                    try {
                                        const result = new Uint8Array(received);
                                        let off = 0;
                                        for (const c of chunks) {
                                            result.set(new Uint8Array(c), off);
                                            off += c.byteLength;
                                        }
                                        chunks = null; // free memory
                                        resolve(result);
                                    } catch (e) {
                                        reject(new Error('Out of memory assembling file ‚Äî try a smaller file or use desktop.'));
                                    }
                                }, 50);
                            }
                        } catch (e) { /* ignore parse errors */ }
                    } else {
                        gotData = true;
                        chunks.push(event.data);
                        received += event.data.byteLength;
                        if (totalSize > 0) {
                            const pct = Math.round((received / totalSize) * 100);
                            progressFill.style.width = pct + '%';
                            progressText.textContent = `‚ö° P2P ${pct}% ‚Äî ${formatBytes(received)} / ${formatBytes(totalSize)}`;
                        }
                    }
                };

                ws.onerror = () => {
                    clearTimeout(timeout);
                    reject(new Error('P2P error'));
                };

                ws.onclose = () => {
                    clearTimeout(timeout);
                    if (!gotData) reject(new Error('P2P closed early'));
                };
            });
        }

        /* ‚îÄ‚îÄ HTTP fallback download ‚îÄ‚îÄ */
        async function downloadViaHTTP(progressFill, progressText) {
            progressText.textContent = 'Downloading encrypted blob...';
            const resp = await fetch(`/api/blob/${dropId}`);

            if (!resp.ok) {
                if (resp.status === 403) throw new Error('Access denied ‚Äî locked to another device.');
                if (resp.status === 404) throw new Error('Drop not found or already destroyed.');
                if (resp.status === 410) throw new Error('Drop already downloaded.');
                throw new Error('HTTP ' + resp.status);
            }

            const contentLength = parseInt(resp.headers.get('Content-Length') || '0');
            const reader = resp.body.getReader();
            const chunks = [];
            let received = 0;

            while (true) {
                const { done, value } = await reader.read();
                if (done) break;
                chunks.push(value);
                received += value.length;

                if (contentLength > 0) {
                    const pct = Math.round((received / contentLength) * 100);
                    progressFill.style.width = pct + '%';
                    progressText.textContent = `Downloading... ${pct}% ‚Äî ${formatBytes(received)} / ${formatBytes(contentLength)}`;
                }
            }

            const encrypted = new Uint8Array(received);
            let offset = 0;
            for (const chunk of chunks) {
                encrypted.set(chunk, offset);
                offset += chunk.length;
            }
            return encrypted;
        }

        /* ‚îÄ‚îÄ Expiry watcher ‚îÄ‚îÄ */
        function setupExpiryWatcher(expiresAt) {
            const check = () => {
                if (new Date() > expiresAt) {
                    encryptionKey = null;
                    passwordSalt = null;
                    document.getElementById('main').classList.add('hidden');
                    document.getElementById('notfound').classList.remove('hidden');
                    document.querySelector('#notfound .burned-title').textContent = 'This drop has expired';
                    document.querySelector('#notfound .burned-sub').textContent =
                        'The encryption key has been wiped from memory.';
                }
            };
            setInterval(check, 5000);
        }

        /* ‚îÄ‚îÄ Helpers ‚îÄ‚îÄ */
        function showError(msg) {
            const el = document.getElementById('status-msg');
            el.className = 'status error active';
            el.textContent = msg;
        }

        function showSuccess(msg) {
            const el = document.getElementById('status-msg');
            el.className = 'status success active';
            el.textContent = msg;
        }

        function formatBytes(b) {
            if (b < 1024) return b + ' B';
            if (b < 1048576) return (b / 1024).toFixed(1) + ' KB';
            if (b < 1073741824) return (b / 1048576).toFixed(1) + ' MB';
            return (b / 1073741824).toFixed(2) + ' GB';
        }
    </script>
</body>
</html>