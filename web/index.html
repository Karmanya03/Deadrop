<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ò† deadrop</title>
    <link rel="stylesheet" href="/assets/style.css">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>‚ò†</text></svg>">
</head>
<body>
    <div class="container">
        <img src="/assets/deadrop-logo.png" alt="deadrop" class="logo-img">

        <div class="card" id="meta-card" style="display:none">
            <div class="meta-row">
                <span class="meta-label">File</span>
                <span class="meta-value" id="meta-filename"></span>
            </div>
            <div class="meta-row">
                <span class="meta-label">Size</span>
                <span class="meta-value" id="meta-size"></span>
            </div>
            <div class="meta-row">
                <span class="meta-label">Expires</span>
                <span class="meta-value" id="meta-expires"></span>
            </div>
            <div class="meta-row">
                <span class="meta-label">Downloads left</span>
                <span class="meta-value" id="meta-downloads"></span>
            </div>
            <div class="meta-row">
                <span class="meta-label">Encryption</span>
                <span class="meta-value">XChaCha20-Poly1305</span>
            </div>
        </div>

        <div class="progress-container" id="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">Initializing...</div>
        </div>

        <p id="status" class="status">Loading...</p>
        <button id="btn" class="btn" style="display:none">Download &amp; Decrypt</button>

        <div class="shield" id="shield" style="display:none">
            üõ° End-to-end encrypted &mdash; decryption key never leaves your device
        </div>
    </div>

    <div class="footer">
        Powered by <a href="/deadrop">deadrop</a> &mdash; zero-knowledge encrypted file sharing
    </div>
</div>

<script type="module">
    // ‚îÄ‚îÄ‚îÄ SECURITY: Extract key and nuke from URL/history immediately ‚îÄ‚îÄ‚îÄ
    const pathParts = window.location.pathname.split('/');
    const dropId = pathParts[pathParts.length - 1];

    let key = null;
    if (window.location.hash && window.location.hash.length > 1) {
        key = window.location.hash.substring(1);
        // Immediately strip the #key from URL bar, history, and back button
        history.replaceState(null, '', window.location.pathname + window.location.search);
    }

    // ‚îÄ‚îÄ‚îÄ DOM refs ‚îÄ‚îÄ‚îÄ
    const statusEl = document.getElementById('status');
    const btnEl = document.getElementById('btn');
    const metaCard = document.getElementById('meta-card');
    const progressCont = document.getElementById('progress-container');
    const progressFill = document.getElementById('progress-fill');
    const progressText = document.getElementById('progress-text');
    const shieldEl = document.getElementById('shield');
    let fileMeta = null;

    // ‚îÄ‚îÄ‚îÄ Validate key presence ‚îÄ‚îÄ‚îÄ
    if (!key) {
        statusEl.innerHTML = '<span class="error">No decryption key found in URL</span>';
        throw new Error('No key');
    }

    // ‚îÄ‚îÄ‚îÄ Fetch metadata ‚îÄ‚îÄ‚îÄ
    async function loadMeta() {
        try {
            const res = await fetch(`/api/meta/${dropId}`);

            // Handle burned drops (HTTP 410 Gone)
            if (res.status === 410) {
                statusEl.innerHTML = '<span class="success">üî• This drop was already downloaded and destroyed.</span>';
                shieldEl.style.display = 'block';
                key = null;
                return;
            }

            if (!res.ok) {
                statusEl.innerHTML = '<span class="error">Drop not found ‚Äî it may have expired or self-destructed</span>';
                return;
            }

            fileMeta = await res.json();
            document.getElementById('meta-filename').textContent = fileMeta.filename;
            document.getElementById('meta-size').textContent = fileMeta.size;
            document.getElementById('meta-downloads').textContent = fileMeta.downloads_remaining;

            // Format expiry
            const expiresAt = new Date(fileMeta.expires_at);
            const diff = expiresAt - Date.now();
            if (diff > 0) {
                const mins = Math.round(diff / 60000);
                document.getElementById('meta-expires').textContent =
                    mins > 60 ? `${Math.round(mins / 60)}h ${mins % 60}m` : `${mins}m`;

                // ‚îÄ‚îÄ‚îÄ SECURITY: Auto-destruct the page when the drop expires ‚îÄ‚îÄ‚îÄ
                setTimeout(() => {
                    key = null;
                    statusEl.innerHTML = '<span class="error">‚è∞ This drop has expired and self-destructed.</span>';
                    btnEl.style.display = 'none';
                    metaCard.style.display = 'none';
                    progressCont.style.display = 'none';
                }, diff);
            } else {
                document.getElementById('meta-expires').textContent = 'Expired';
            }

            metaCard.style.display = 'block';
            shieldEl.style.display = 'block';
            btnEl.style.display = 'inline-block';
            statusEl.textContent = 'Ready to download';
        } catch (e) {
            statusEl.innerHTML = `<span class="error">Connection failed: ${e.message}</span>`;
        }
    }

    // ‚îÄ‚îÄ‚îÄ Trigger file save (universal) ‚îÄ‚îÄ‚îÄ
    function saveFile(arrayBuffer, filename, mime) {
        const blob = new Blob([arrayBuffer], { type: mime });

        if ('showSaveFilePicker' in window) {
            showSaveFilePicker({ suggestedName: filename })
                .then(handle => handle.createWritable())
                .then(writable => writable.write(blob).then(() => writable.close()))
                .then(() => onSuccess())
                .catch(err => {
                    if (err.name !== 'AbortError') {
                        fallbackDownload(blob, filename);
                    }
                });
        } else {
            fallbackDownload(blob, filename);
        }
    }

    function fallbackDownload(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
            URL.revokeObjectURL(url);
            document.body.removeChild(a);
        }, 1000);
        onSuccess();
    }

    function onSuccess() {
        progressFill.style.width = '100%';
        progressFill.style.background = '#00ff88';
        statusEl.innerHTML = '<span class="success">‚úÖ Decrypted and saved! This drop has self-destructed on the server.</span>';
        btnEl.style.display = 'none';
        progressText.textContent = 'Complete';

        // ‚îÄ‚îÄ‚îÄ SECURITY: Nuke the key from memory after successful download ‚îÄ‚îÄ‚îÄ
        key = null;
    }

    // ‚îÄ‚îÄ‚îÄ Download & Decrypt via Web Worker ‚îÄ‚îÄ‚îÄ
    async function startDecrypt() {
        btnEl.disabled = true;
        btnEl.textContent = 'Decrypting...';
        progressCont.style.display = 'block';

        if (typeof Worker !== 'undefined') {
            const worker = new Worker('/assets/worker.js', { type: 'module' });

            worker.onmessage = (e) => {
                const msg = e.data;
                switch (msg.type) {
                    case 'progress':
                        progressFill.style.width = msg.percent;
                        break;
                    case 'status':
                        progressText.textContent = msg.message;
                        break;
                    case 'complete':
                        saveFile(msg.data, msg.filename, msg.mime);
                        worker.terminate();
                        break;
                    case 'error':
                        statusEl.innerHTML = `<span class="error">${msg.message}</span>`;
                        progressFill.style.background = '#ff4444';
                        btnEl.textContent = 'Retry';
                        btnEl.disabled = false;
                        worker.terminate();
                        break;
                }
            };

            worker.onerror = (e) => {
                statusEl.innerHTML = `<span class="error">Worker error: ${e.message}</span>`;
                btnEl.textContent = 'Retry';
                btnEl.disabled = false;
            };

            worker.postMessage({
                action: 'decrypt',
                dropId: dropId,
                key: key,
                filename: fileMeta.filename,
                mime: fileMeta.mime,
            });

        } else {
            statusEl.textContent = 'Decrypting on main thread...';
            try {
                const wasm = await import('/wasm/deadrop_wasm.js');
                await wasm.default();
                const res = await fetch(`/api/blob/${dropId}`);
                const encrypted = new Uint8Array(await res.arrayBuffer());
                progressFill.style.width = '50%';
                const plaintext = wasm.decrypt_blob(encrypted, key);
                progressFill.style.width = '90%';
                saveFile(plaintext.buffer, fileMeta.filename, fileMeta.mime);
            } catch (e) {
                statusEl.innerHTML = `<span class="error">${e.message} ${e}</span>`;
                btnEl.textContent = 'Retry';
                btnEl.disabled = false;
            }
        }
    }

    // ‚îÄ‚îÄ‚îÄ Wire up button ‚îÄ‚îÄ‚îÄ
    btnEl.addEventListener('click', startDecrypt);

    // ‚îÄ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ
    loadMeta();
</script>
</body>
</html>